(in-package :mo)

;;; load file make-ff-lexicon.lisp

;;; WORKS FOR NEMEXA AND NEMEXF
#|
Format 
0 utf-8 EN 5 5
1 -9.197762 kaushik#ch NG:1:-9.197762
2 -9.197762 chakrabarti NG:1:-9.197762
|#


#|

get all entries via
(dtree::match-entry ".*" *stem-lexicon*)
(dtree::match-entry ".*" *fullform-lexicon*)

eventually also (enumerate-homographs ".*")

for each found entry, encode its lexicon information:

(compute-stem-entry XX)
(compute-fullform-entry YY)

If multiple:
loop through POS-readings
collect POS; if no POS, Determine POS information using stem pointer



|#

;;; check whether wordform as SS in it then mark it

(defun contains-double-s (string)
  (let ((pos-first-s (position #\s string)))
    (when pos-first-s
      (when (< pos-first-s (1- (length string)))
	(char-equal #\s (aref  string (1+ pos-first-s)))))))

;;; get the pos if available, if not, get via stamm pointer
(defun get-pos-rest-value (key assoc-list)
  (let ((found-pos (rest (assoc 'wortart assoc-list))))
    (if found-pos found-pos
	(if (assoc 'stamm assoc-list)
	    (get-pos-for-pointered-entry key (first assoc-list))
	    (pprint key)))
    )
  )

;;; only in case of fullforms; no stamm pointer assumed here
(defun get-pos-cadr-value (key assoc-list)
  (cadr (assoc 'wortart assoc-list))
  )

;;; get the wortart for the stamm pointer entry
;;; MISSING: stamm-lemma is lost -> add it to entry
(defun get-pos-for-pointered-entry (key pointer-entry)
  (let* ((pointered-key (get-pointered-key pointer-entry))
	 (pointered-segment-type  (get-pointered-segment pointer-entry))
	 (result (find-associate-category pointered-segment-type
					  (compute-stem-entry pointered-key) 
					  key pointered-key)))
    (rest (assoc 'wortart result))
    )
  )

(defun morphix-to-nemex (path node compute-morphix-function get-pos-retrieval)
  (let ((leaf (cdr (assoc :info (dtree::node-content node)))))
    (when leaf
      (let* ((word (format nil "窿疳翳┅戾孱趄ㄦ躅汜祆泔眇豸瀛盹蝠栝骢钽糸镱黠蜾┅蹴灬豸翦篝骘颦蹴灬豸黠蜾┅ㄤ秕忪弩ㄣ镱翎轭蟓滹踱戾黠蜾┅ㄡ趑蜷怩翦ㄩ狒趄殁豸弩ㄩㄡ钿蹴灬豸滹踱戾螬⒘栽医蹴灬豸滹踱戾螈ㄩ蹴灬豸⒘栽医蹴灬豸ㄩ滹踱戾⒘栽医滹踱戾螈┅┅眭祠轲戾孱趄眭祠轲戾泔眇豸邃孱趄戾孱趄┅躅戾篌ㄥ聃犰狒趄殁豸ㄩ钽狒趄泐舄┅ㄩ眭祠轲戾孱趄戾舄è黠螋狎翦祜镳骘轭蝈篝戾孱趄泔祆邈ㄡ痧禊珏舡痫蟓蝈趄殄鲠扉篝黠蜾┅┅铄礤孱趄ㄦ矧磲铋爱梁焙爱A" (incf *cnt*) word wortarten attribute))
		   )
	      (format *out-stream* "&A%" nemex-entry))
	    (let* ((info (if (listp (first lex-entry)) lex-entry (rest lex-entry)))
		   (wortart (apply get-pos-retrieval (list word info)))
		   (nemex-entry (format nil "A 0.0 A A:1:0.0 A" (incf *cnt*) word wortart attribute)))
	      (format *out-stream* "&A%" nemex-entry))
	    )))))

(defun ff-to-nemex (path node)
  (morphix-to-nemex path node #'compute-fullform-entry #'get-pos-cadr-value))

(defun stem-to-nemex (path node)
  (morphix-to-nemex path node #'compute-stem-entry #'get-pos-rest-value))

(defun make-nemex-entries (&key
			     (attributes t)
			     (tofile "/Users/gune00/dfki/src/Lisp/morphix/pd-vers/fullform/morphix-nemex.txt")
			     (expr ".*"))
  (let ((*cnt* 0)
	(*attr-cnt* 0)
	(*attributes* attributes)
	(*out-stream* (open tofile :direction :output
			    :if-exists :supersede
			    :if-does-not-exist :create)))
    (declare (special *out-stream* *cnt* *attr-cnt* *attributes*))
    
    (dtree::match-entry expr *fullform-lexicon* :output-fn #'ff-to-nemex)
    (dtree::match-entry expr *stem-lexicon* :output-fn #'stem-to-nemex)
    
    (format *out-stream* "&0 utf-8 DE a a%" *cnt* *cnt*)
    (close *out-stream*)

    (values *cnt* *attr-cnt*)
    )
  )


#|
Missing:
- handle STEM pointers if no WORTART is available -> OK
- weights -> use dummies here
- output to file -> OK; "/Users/gune00/dfki/src/Lisp/morphix/pd-vers/fullform/morphix-nemex.txt"

callers:

(make-nemex-entries :attributes nil) 
  -> creates nemex file directly 
  -> I tested it with NemexF and it works !
(make-nemex-entries :attributes T)
  -> this is for creating attributes

- create initial line for file for meta information 
  -> OK, must be moved to first line of file manually

- do umlauting on file with attributes
   -> manually check entries and change ATTR=XY entries and remove feature
|#
